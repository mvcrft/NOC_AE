/*    Let's keep adding to our vector library with normalize.*/function createVector(x_,y_) {    this.x = x_;    this.y = y_;}//let's create the normalize function. I'm having trouble getting functions to recognize already created functions in the object, so I manually typed out the normalize steps. Hmm.vMath = new function() {    this.add  = function(v1,v2){  v1.x += v2.x;  v1.y += v2.y;  };    this.sub  = function(v1,v2){  v1.x -= v2.x;  v1.y -= v2.y;  };    this.mult  = function(v1,n){   v1.x *= n;    v1.y *= n;  };    this.div  = function(v1,n){   v1.x /= n;    v1.y /= n;  };    this.mag  = function(v1){ return Math.sqrt((v1.x * v1.x) + (v1.y * v1.y))};        this.normalize = function(v1){        //first, get the magnitude        m = Math.sqrt((v1.x * v1.x) + (v1.y * v1.y));        //then, divide after checking for zero.        if (m != 0){             v1.x /= m;            v1.y /= m;            }        }    }var myComp = app.project.item(6);var centerX = myComp.width/2;var centerY = myComp.height/2;function randomVal(max){return Math.abs(Math.random())*max;}var interval = 6;var myFrameDuration = myComp.frameDuration*interval;var totalFrames = (myComp.duration * myComp.frameRate)/interval;//here's the Nature of Code vector normalize example. We'll do the same thing with a Null to visualize the original vector.for (i = 0; i<=totalFrames;i++){        var center = new createVector(centerX,centerY);     var mouse = new createVector(randomVal(myComp.width),randomVal(myComp.height));        vMath.sub(mouse,center);    var mouseOriginal = new createVector(mouse.x,mouse.y);    vMath.normalize(mouse);    vMath.mult(mouse,100);        mouse.x += myComp.width/2;    mouseOriginal.x += myComp.width/2;    mouse.y += myComp.height/2;    mouseOriginal.y += myComp.height/2;        var beamEffect = myComp.layer(1).property("Effects").property("Beam");        beamEffect.property("Starting Point").setValueAtTime(myFrameDuration*i,[centerX,centerY]);    beamEffect.property("Ending Point").setValueAtTime(myFrameDuration*i,[mouse.x,mouse.y]);    myComp.layer(2).position.setValueAtTime(myFrameDuration*i,[mouseOriginal.x,mouseOriginal.y]);//While the intervals make it less tweaky to look at, interpolation is making it hard to see the result. Let's set the keyframe types to Hold with setInterpolationTypeAtKey().beamEffect.property("Starting Point").setInterpolationTypeAtKey(i+1, KeyframeInterpolationType.HOLD);beamEffect.property("Ending Point").setInterpolationTypeAtKey(i+1, KeyframeInterpolationType.HOLD);myComp.layer(2).position.setInterpolationTypeAtKey(i+1, KeyframeInterpolationType.HOLD);};/*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/ 