/* Now, let's implement acceleration.*/var myComp = app.project.item(8);var myMover;function createVector(x_,y_) {    this.x = x_;    this.y = y_;}vMath = new function() {    this.add  = function(v1,v2){  v1.x += v2.x;  v1.y += v2.y;  };    this.sub  = function(v1,v2){  v1.x -= v2.x;  v1.y -= v2.y;  };    this.mult  = function(v1,n){   v1.x *= n;    v1.y *= n;  };    this.div  = function(v1,n){   v1.x /= n;    v1.y /= n;  };    this.mag  = function(v1){ return Math.sqrt((v1.x * v1.x) + (v1.y * v1.y))};    this.normalize = function(v1){        //first, get the magnitude        m = Math.sqrt((v1.x * v1.x) + (v1.y * v1.y));        //then, divide after checking for zero.        if (m != 0){             v1.x /= m;            v1.y /= m;            }        }    //I think this is working- I looked at p5, and it normalizes the vector and then multiplies by max rather than setting it like I am doing here. This gave me some very strange functionality.../*    this.limit = function(v1, max){        mSq = (v1.x * v1.x) + (v1.y * v1.y);        if (mSq > max * max){            mag = Math.sqrt(mSq);            v1.x /= mag;              v1.y /= mag;            v1.x * max;            v1.y * max;            };                */        this.limit = function(v1, max){        mSq = (v1.x * v1.x) + (v1.y * v1.y);        if (mSq > max * max){            (v1.x = max);              (v1.y = max);            };        };    };r = new function(){this.randomVal = function(max){return Math.abs(Math.random())*max;};this.randomRange = function(min,max){return (Math.random()*max) + min;};}var Mover = function() {  this.position = new createVector((r.randomVal(myComp.width)), (r.randomVal(myComp.height)));  this.velocity = new createVector(0,0);  this.acceleration = new createVector(1, 1);  this.topspeed = 30; };Mover.prototype.update = function() {    vMath.add(this.velocity,this.acceleration);    vMath.limit(this.velocity,this.topspeed);    vMath.add(this.position,this.velocity);};//Notice that display is now a functionMover.prototype.display = function(time) {    myComp.layer(1).position.setValueAtTime(time,[this.position.x,this.position.y]);};        Mover.prototype.checkEdges = function() {    if (this.position.x > myComp.width) {        this.position.x = 0;        }else if (this.position.x < 0) {            this.position.x = myComp.width;            };    if (this.position.y > myComp.height) {        this.position.y = 0;        }else if (this.position.y < 0) {            this.position.y = myComp.height;            };};myMover = new Mover();var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;//setup()myComp.layers.addShape();myComp.layer(1).property("ADBE Root Vectors Group").addProperty("ADBE Vector Shape - Ellipse");myComp.layer(1).property("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");myComp.layer(1).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([1,1,1,1]);//draw()for (i = 0; i<=totalFrames;i++){    myMover.update();    myMover.checkEdges();    myMover.display((myFrameDuration*i));};    /*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/    