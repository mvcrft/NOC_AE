/* Now, let's implement acceleration. I'm still learning about Extendscript which seems to be much more strict in the ordering which it evaluates functions as opposed to javascript. This lead me to build my vMath library unkowingly as static functions. Now that we've learned about them, I've written a Vector Class in addition to the static functions.    *///Okay, lots of cleanup! First, I've created a vector object and function for making new vectors which more closely mirrors the Nature of Code examples.function Vector(x_,y_) {    this.x = x_;    this.y = y_;}function createVector(x_,y_){    return new Vector(x_,y_);}//Now, let's extend the class with prototype and add in our vector functions. This means the functions will modify the object itself rather than a copy.Vector.prototype.add = function(v){    this.x += v.x;    this.y += v.y;    };Vector.prototype.sub = function(v){    this.x -= v.x;    this.y-= v.y;    };Vector.prototype.mult = function(n){    this.x *= n;    this.y *= n;    };Vector.prototype.div = function(n){    this.x /= n;    this.y /= n;};Vector.prototype.magSq = function(){    return (this.x*this.x)+(this.y*this.y);    }//This seems to work, now, too. Was having problems calling functions in functions in ExtendScript.Vector.prototype.mag = function(){    return Math.sqrt(this.magSq());    }Vector.prototype.normalize = function(){    var mag = this.mag();    if (mag != 0){        this.x /= mag;        this.y /= mag;        }    };Vector.prototype.limit = function(max){    var mSq = this.magSq();    if (mSq > max*max){        this.div(Math.sqrt(mSq));        this.mult(max);        }};//Here's the old static vMath functions. We'll need these in the next example./*vMath = new function() {    this.add  = function(v1,v2){  v1.x += v2.x;  v1.y += v2.y;  };    this.sub  = function(v1,v2){  v1.x -= v2.x;  v1.y -= v2.y;  };    this.mult  = function(v1,n){   v1.x *= n;    v1.y *= n;  };    this.div  = function(v1,n){   v1.x /= n;    v1.y /= n;  };    this.mag  = function(v1){ return Math.sqrt((v1.x * v1.x) + (v1.y * v1.y))};    this.normalize = function(v1){        //first, get the magnitude        m = Math.sqrt((v1.x * v1.x) + (v1.y * v1.y));        //then, divide after checking for zero.        if (m != 0){             v1.x /= m;            v1.y /= m;            }        }    this.limit = function(v1, max){        mSq = (v1.x * v1.x) + (v1.y * v1.y);        if (mSq > max * max){            (v1.x = max);              (v1.y = max);            };        };    };*/r = new function(){this.randomVal = function(max){return Math.abs(Math.random())*max;};this.randomRange = function(min,max){return (Math.random()*max) + min;};}var myComp = app.project.item(9);var myMover;var Mover = function() {  this.position = createVector((myComp.width/2), (myComp.height/2));  this.velocity = createVector(0,0);  this.acceleration = createVector(0,0);  this.topspeed = 20; };//I'm looking at the P5 Examples here for the update.Mover.prototype.update = function() {    //first, create a randomValue    var angle = r.randomVal(Math.PI * 2);    //feed it into sin and cosine and create a vector.    this.acceleration = createVector((Math.cos(angle)),(Math.sin(angle)));    //since that returns a value of -1,1 so feel free to multiply it.    this.acceleration.mult(r.randomVal(8));        this.velocity.add(this.acceleration);    this.velocity.limit(this.topspeed);    this.position.add(this.velocity);};      Mover.prototype.display = function(time) {    myComp.layer(1).position.setValueAtTime(time,[this.position.x,this.position.y]);};           Mover.prototype.checkEdges = function() {    if (this.position.x > myComp.width) {        this.position.x = 0;        }else if (this.position.x < 0) {            this.position.x = myComp.width;            };    if (this.position.y > myComp.height) {        this.position.y = 0;        }else if (this.position.y < 0) {            this.position.y = myComp.height;            };};myMover = new Mover();var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;//setup()    myComp.layers.addShape();    myComp.layer(1).property("ADBE Root Vectors Group").addProperty("ADBE Vector Shape - Ellipse");    myComp.layer(1).property("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");    myComp.layer(1).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([1,1,1,1]);//draw()for (i = 0; i<=totalFrames;i++){    myMover.update();    myMover.checkEdges();    myMover.display((myFrameDuration*i));};    /*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/    