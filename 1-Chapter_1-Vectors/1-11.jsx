/* Let's bring it home. Now things are finally getting interesting: We are getting some results that would be challenging to replicate with the AE interface. The trick is going to be looping in time, and looping through the layers.    */function Vector(x_,y_) {    this.x = x_;    this.y = y_;}function createVector(x_,y_){    return new Vector(x_,y_);}Vector.prototype.add = function(v){    this.x += v.x;    this.y += v.y;    };Vector.prototype.sub = function(v){    this.x -= v.x;    this.y-= v.y;    };Vector.prototype.mult = function(n){    this.x *= n;    this.y *= n;    };Vector.prototype.div = function(n){    this.x /= n;    this.y /= n;};Vector.prototype.magSq = function(){    return (this.x*this.x)+(this.y*this.y);    }Vector.prototype.mag = function(){    return Math.sqrt(this.magSq());    }Vector.prototype.setMag = function(n){    this.normalize();    this.mult(n);    }Vector.prototype.normalize = function(){    var mag = this.mag();    if (mag != 0){        this.x /= mag;        this.y /= mag;        }    };Vector.prototype.limit = function(max){    var mSq = this.magSq();    if (mSq > max*max){        this.div(Math.sqrt(mSq));        this.mult(max);        }};vMath = new function() {    this.sub  = function(v1,v2){ return new Vector( v1.x -= v2.x,  v1.y -= v2.y);  };    };r = new function(){this.randomVal = function(max){return Math.abs(Math.random())*max;};this.randomRange = function(min,max){return (Math.random()*max) + min;};}var myComp = app.project.item(11);var myMover;var Mover = function() {  this.position = createVector(r.randomRange(0,myComp.width),r.randomRange(0,myComp.height));  this.velocity = createVector(0,0);  this.acceleration = createVector(0,0);  this.topspeed = 20; };// let's pass time as an argument.Mover.prototype.update = function(time) {    var mouseVal = myComp.layer(1).position.valueAtTime(time,true);    mouse = new createVector(mouseVal[0],mouseVal[1]);    this.acceleration = vMath.sub(mouse,this.position);    this.acceleration.setMag(1.2);    this.velocity.add(this.acceleration);    this.velocity.limit(this.topspeed);    this.position.add(this.velocity);};      Mover.prototype.display = function(layerNum,time) {    myComp.layer(layerNum).position.setValueAtTime(time,[this.position.x,this.position.y]);};           Mover.prototype.checkEdges = function() {    if (this.position.x > myComp.width) {        this.position.x = 0;        }else if (this.position.x < 0) {            this.position.x = myComp.width;            };    if (this.position.y > myComp.height) {        this.position.y = 0;        }else if (this.position.y < 0) {            this.position.y = myComp.height;            };};// Let's make an array. I'm a little torn on this, because we can also call an array in AE using layers but I'd like to still match the Nature of Code Examples.var movers = [];var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;//setup()//Let's set up a new loop to make new layers, and also push instances of Mover() to the array. Change the value here to add as many Movers to the comp as you like.for (i =0;i<15;i++){     myComp.layers.addShape();    myComp.layer(1).moveAfter(myComp.layer(2));    myComp.layer(2).property("ADBE Root Vectors Group").addProperty("ADBE Vector Shape - Ellipse");    rand = r.randomRange(15,100);    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Shape - Ellipse").property("ADBE Vector Ellipse Size").setValue([rand,rand]);    myComp.layer(2).property("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([1,1,1,1]);    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Opacity").setValue(r.randomVal(100));    movers.push(new Mover());};//draw()//and let's loop through the values, and also loop through the time. for (i = 0; i<=totalFrames;i++){        var time = myFrameDuration*i;    for (var j = 0;j < movers.length; j++){    movers[j].update(time);    movers[j].checkEdges();    movers[j].display(j+2,time);    };};    /*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/    