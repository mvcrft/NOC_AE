/* Now, let's implement acceleration. I'm still learning about Extendscript which seems to be much more strict in the ordering which it evaluates functions as opposed to javascript. This lead me to build my vMath library unkowingly as static functions!. Now that we've learned about them, I've written a Vector Class in addition to the static functions.    *///Okay, lots of cleanup! First, I've created a vector object and function for making new vectors which more closely mirrors the Nature of Code examples.function Vector(x_,y_) {    this.x = x_;    this.y = y_;}function createVector(x_,y_){    return new Vector(x_,y_);}//Now, let's extend the class with prototype and add in our vector functions. This means the functions will modify the object itself rather than a copy.Vector.prototype.add = function(v){    this.x += v.x;    this.y += v.y;    };Vector.prototype.sub = function(v){    this.x -= v.x;    this.y-= v.y;    };Vector.prototype.mult = function(n){    this.x *= n;    this.y *= n;    };Vector.prototype.div = function(n){    this.x /= n;    this.y /= n;};Vector.prototype.magSq = function(){    return (this.x*this.x)+(this.y*this.y);    }Vector.prototype.mag = function(){    return Math.sqrt(this.magSq());    }Vector.prototype.setMag = function(n){    this.normalize();    this.mult(n);    }Vector.prototype.normalize = function(){    var mag = this.mag();    if (mag != 0){        this.x /= mag;        this.y /= mag;        }    };Vector.prototype.limit = function(max){    var mSq = this.magSq();    if (mSq > max*max){        this.div(Math.sqrt(mSq));        this.mult(max);        }};//Here's a new static vMath function. All we need for this example is subtract.vMath = new function() {    this.sub  = function(v1,v2){ return new Vector( v1.x -= v2.x,  v1.y -= v2.y);  };    };r = new function(){this.randomVal = function(max){return Math.abs(Math.random())*max;};this.randomRange = function(min,max){return (Math.random()*max) + min;};}var myComp = app.project.item(11);var myMover;var Mover = function() {  this.position = createVector(r.randomRange(0,myComp.width),r.randomRange(0,myComp.height));  this.velocity = createVector(0,0);  this.acceleration = createVector(0,0);  this.topspeed = 20; };//I'm looking at the P5 Examples here. Also, I'm going to pass time so we can get the value of the first layer's position. We'll need to create a vector from the mouse position, and then subtract them. setMag controls how tight the mover follows the null.Mover.prototype.update = function(time) {    var mouseVal = myComp.layer(1).position.valueAtTime(time,true);    mouse = new createVector(mouseVal[0],mouseVal[1]);    this.acceleration = vMath.sub(mouse,this.position);    this.acceleration.setMag(1.2);    this.velocity.add(this.acceleration);    this.velocity.limit(this.topspeed);    this.position.add(this.velocity);};      Mover.prototype.display = function(layerNum,time) {    myComp.layer(layerNum).position.setValueAtTime(time,[this.position.x,this.position.y]);};           Mover.prototype.checkEdges = function() {    if (this.position.x > myComp.width) {        this.position.x = 0;        }else if (this.position.x < 0) {            this.position.x = myComp.width;            };    if (this.position.y > myComp.height) {        this.position.y = 0;        }else if (this.position.y < 0) {            this.position.y = myComp.height;            };};var movers = [];myMover = new Mover();var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;//setup()for (i =0;i<5;i++){     myComp.layers.addShape();    myComp.layer(1).moveAfter(myComp.layer(2));    myComp.layer(2).property("ADBE Root Vectors Group").addProperty("ADBE Vector Shape - Ellipse");    rand = r.randomRange(15,100);    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Shape - Ellipse").property("ADBE Vector Ellipse Size").setValue([rand,rand]);    myComp.layer(2).property("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([1,1,1,1]);    myComp.layer(2).property("ADBE Root Vectors Group").property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Opacity").setValue(r.randomVal(100));    movers.push(new Mover());};//draw()for (i = 0; i<=totalFrames;i++){        var time = myFrameDuration*i;    for (var j = 0;j < movers.length; j++){    movers[j].update(time);    movers[j].checkEdges();    movers[j].display(j+2,time);    };};    /*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/    