/*    Ok, things are getting a bit complex, with multiple "classes" needed. Let's split the functionality into different files to make things easier to read and encapsulate some functionality. I'm primarily looking at Shiffman's p5 examples here, although some weirdness is happening as I interact with After Effects, mainly in that it is a bit hard to encapsulate functionality in a single object when also interacting with a larger framework of After Effects. As it is, I've just decided that Movers and classes should have a layer and comp attribute so they know where they are in the overall project file. Other than that, I'm not making a whole lot of changes to the code, outside of making the variable names a little easier for me to read.     It's important to have forces react to the properties of objects. (Think of the possibilities with After Effects, with dozens of properties we could add to layers!)  */#include VectorLib.jsx//once we're done working on our classes, we will have something like this.//#include mover.jsx//#include liquid.jsx//Here's the liquid class//What does the liquid need to know about itself? For this object, we're assuming the liquid is of constant density and a rectangle. I'm passing in the position, width, height, co-efficient of drag, comp, and layers properties.var Liquid = function(comp,layer,xPos,yPos,width,height,constant){    this.comp = comp;    this.layerNum = layer;    this.x = xPos;    this.y = yPos;    this.width = width;    this.height = height;    this.c = constant;     };//Here, we will create a condition that returns true if the mover's position is whithin the liquid rectangle.Liquid.prototype.contains = function(mover){    var mover = mover.position;    return mover.x > this.x && mover.x < this.x + this.width && mover.y > this.y && mover.y< this.y + this.height;    };//This is the main drag calculation.Liquid.prototype.calculateDrag = function(mover){        /*    Drag gets a Co-Efficient - the liquid class "c" for constant.    Force of Drag could be simplified to Force = - c * velocity * normalized mag    Surface area of the Movers makes a big difference when calculating drag - this example makes that value a constant for now.    Magnitude of the drag is coefficient * speed squared. The idea here is that the faster something moves, the more resistance is applied.    */    var speed = mover.velocity.mag();    var dragMagnitude = this.c * speed * speed;        //Next, get a copy of the Mover's velocity    var dragForce = m.velocity.get();        // Then, calculate the inverse Direction.    dragForce.mult(-1);        // Finally, let's scale according to magnitude        // this should work, since we took the time to create it in our VectorLibrary – not quite sure why Shiffman commented it out in his p5 examples. dragForce.setMag(dragMagnitude);    dragForce.normalize();    dragForce.mult(dragMagnitude);        return dragForce;        };//This method just draws the "water" on screen. Notice it gets values from the liquid class properties rather then the comp itself. I'm a little on the fence about this, we could pass in a comp object and pull out property values rather than hard-coding them.Liquid.prototype.display = function(){    app.project.item(this.comp).layers.addShape();    var layerShapeContents = app.project.item(this.comp).layer(this.layerNum).property("ADBE Root Vectors Group");    layerShapeContents.addProperty("ADBE Vector Shape - Rect");    layerShapeContents.property("ADBE Vector Shape - Rect").property("ADBE Vector Rect Size").setValue([this.width, this.height]);        app.project.item(this.comp).layer(this.layerNum).property("Transform").property("Position").setValue([this.x, this.y]);    app.project.item(this.comp).layer(this.layerNum).property("Transform").property("Opacity").setValue(50);        // quick note- we need to translate these values because Shape layer contents begin counting relative to the layer's position property, rather than using comp space. This will just ensure the rectangle draws from the upper left hand corner rather than the center.        layerShapeContents.property("ADBE Vector Shape - Rect").property("Position").setValue([this.width/2,this.height/2]);            layerShapeContents.addProperty("ADBE Vector Graphic - Fill");    layerShapeContents.property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([.5,.5,.5,1]);        app.project.item(this.comp).layer(this.layerNum).name = "Liquid";    };//Here's the Mover "class"var Mover = function(comp,layerNum,mass,x,y) {  this.comp = comp;  this.layerNum = layerNum;  this.mass = mass;  this.position = createVector(x,y);  this.velocity = createVector(0,0);  this.acceleration = createVector(0,0);};Mover.prototype.applyForce = function(force){    var f = Vector.div(force,this.mass);    this.acceleration.add(f);    }Mover.prototype.update = function(time) {    this.velocity.add(this.acceleration);    this.position.add(this.velocity);    this.acceleration.mult(0);};      Mover.prototype.display = function( time ) {    app.project.item(this.comp).layer(this.layerNum).position.setValueAtTime(time,[this.position.x,this.position.y]);    };//Notice the checkEdges method has been simplified.Mover.prototype.checkEdges = function() {     var comp = app.project.item(this.comp);  if (this.position.y > comp.height) {    this.velocity.y *= -0.9;  // A little dampening when hitting the bottom    this.position.y = comp.height;  }};        Mover.prototype.show = function(){    var layerShapeContents = app.project.item(this.comp).layer(this.layerNum).property("ADBE Root Vectors Group");        //We're still multiplying mass by kind of an arbitrary scalar, feel free to change this value.    var size = 16;        //Let's assign the visual properties to the shape layer    layerShapeContents.addProperty("ADBE Vector Shape - Ellipse");    layerShapeContents.property("ADBE Vector Shape - Ellipse").property("ADBE Vector Ellipse Size").setValue([this.mass * size,this.mass * size]);    layerShapeContents.addProperty("ADBE Vector Graphic - Fill");    layerShapeContents.property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([.25,.25,.25,1]);     layerShapeContents.property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Opacity").setValue(r.randomRange(30,90));        //Since we have multiple layers, let's name it "Mover" too.    app.project.item(this.comp).layer(this.layerNum).name = "Mover";            }//I'm thinking of re-writing this and pushing it to the Vector Math Library, since I'm re-using it so much. Eventually the Vector Math Library will become "p5"-ish.r = new function(){this.randomVal = function(max){return Math.abs(Math.random())*max;};this.randomRange = function(min,max){return Math.random()*(max-min) + min;};}//Let's initialize the values.var comp = 5;var myComp = app.project.item(comp);//Create the array and the Liquid Object.var movers = [];//Rather than hard coding the liquid values, let's get values from the Comp.var liquidPosX = 0;var liquidPosY = myComp.height/2;var liquidWidth = myComp.width;var liquidHeight = myComp.height/2;var liquidDensity= .1;var liquid = new Liquid(comp,1,liquidPosX,liquidPosY,liquidWidth,liquidHeight,liquidDensity);var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;var moverTotal = 10;//setup() //We'll have to be careful, because now we'll have an extra layer: liquid. Notice the layer values being passed to the Mover object (i+2) account for this, so skip layer 0 (which doesn't exist) and layer 1 (which is the liquid). for (i = 0;i<=moverTotal;i++){     myComp.layers.addShape();    var mass = r.randomRange(1,5);    m = new Mover(comp,i+2, mass, 110 + i * 110 , 0);    movers.push(m);};//let's draw the liquid onscreen.liquid.display();//The next loop will assign the show properties to each mover and layer.for (i = 0;i<=moverTotal;i++){    movers[i].show();    }//draw()//Now we will loop through time and loop through the layers. We need to create a condition to test if the movers are in the liquid, and then apply the Drag force if it returns true.for (i = 0; i<=totalFrames;i++){        var time = myFrameDuration*i;        for (var j = 0;j < myComp.layers.length-1; j++){                if (liquid.contains(movers[j])){            var dragForce = liquid.calculateDrag(movers[j]);                        movers[j].applyForce(dragForce);            }        //Here's gravity, which accounts for the mass of the Movers.        var gravity = createVector(0,0.1*movers[j].mass)                movers[j].applyForce(gravity);        movers[j].update(time);        movers[j].checkEdges();        movers[j].display(time);        }};    /*As always, refer to The Nature of Code byDaniel Shiffmanhttp://natureofcode.comfor original examples!*/    