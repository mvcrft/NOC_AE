//Let's fold the attractor functionality into the Mover object for Self-Attraction.#include VectorLib.jsxvar Mover = function(comp,layerNum,mass,G,x,y) {  this.comp = comp;  this.layerNum = layerNum;  this.mass = mass;  this.G = G;  this.position = createVector(x,y);  this.velocity = createVector(0,0);  this.acceleration = createVector(0,0);};Mover.prototype.applyForce = function(force){    var f = Vector.div(force,this.mass);    this.acceleration.add(f);    };Mover.prototype.update = function() {    this.velocity.add(this.acceleration);    this.position.add(this.velocity);    this.acceleration.mult(0);};      Mover.prototype.display = function( time ) {    app.project.item(this.comp).layer(this.layerNum).position.setValueAtTime(time,[this.position.x,this.position.y]);    };//We will move the attraction functionality to the mover object.Mover.prototype.calculateAttraction = function(m){//subtract one position from the othervar force = Vector.sub(this.position, m.position);//get the lengthvar distance = force.mag();//we're going to need to build a constrain function. I've included it in VectorLib. Maybe Vectorlib needs a new name. Feel free to dial these values up and down.distance = constrain(distance, 5, 25);//normalize the vectorforce.normalize();//here's the gravitational force magnitude. this returns a scalar.var strength = (this.G*this.mass*this.mass) / (distance*distance);//get force vector and multiply!force.mult(strength);return force;};Mover.prototype.show = function(){    var layerShapeContents = app.project.item(this.comp).layer(this.layerNum).property("ADBE Root Vectors Group");        var size = 32;        //Let's assign the visual properties to the shape layer    layerShapeContents.addProperty("ADBE Vector Shape - Ellipse");    layerShapeContents.property("ADBE Vector Shape - Ellipse").property("ADBE Vector Ellipse Size").setValue([this.mass * size,this.mass * size]);    layerShapeContents.addProperty("ADBE Vector Graphic - Fill");    layerShapeContents.property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Color").setValue([.25,.25,.25,1]);     layerShapeContents.property("ADBE Vector Graphic - Fill").property("ADBE Vector Fill Opacity").setValue(r.randomRange(30,90));        app.project.item(this.comp).layer(this.layerNum).name = "Mover";       };var comp = 8;var movers = [];var myComp = app.project.item(comp);var myFrameDuration = myComp.frameDuration;var totalFrames = myComp.duration * myComp.frameRate;var moverTotal = 10;//Crank the Gravitational constant up and down for fun results!var G = 10;for (i = 0;i<moverTotal;i++){     myComp.layers.addShape();    var mass = r.randomRange(.1,2);    var xPos = r.randomRange(0,myComp.width);    var yPos = r.randomRange(0,myComp.height);    m = new Mover(comp,i+1, mass, G , xPos , yPos);    movers.push(m);};for (i = 0;i<moverTotal;i++){    movers[i].show();};//We have to nest 3 "for" loops! First, the frames, then the layers, then the comparision conditions. for (i = 0; i<=totalFrames;i++){            var time = myFrameDuration*i;         for (var j = 0;j < movers.length; j++){         for (var k = 0;k<movers.length;k++){             if (j != k){                 var force = movers[k].calculateAttraction(movers[j]);                 movers[j].applyForce(force);                 };             }                       movers[j].update();             movers[j].display(time);    };    };